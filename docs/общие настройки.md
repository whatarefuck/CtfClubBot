# Документация по настройке конфигурации в проекте

## Содержание

- [Общее описание конфигурации](#общее-описание-конфигурации)
- [Структура и расположение конфигурации](#структура-и-расположение-конфигурации)
- [Работа с переменными окружения и файлом .env](#работа-с-переменными-окружения-и-файлом-env)
- [Получение доступа к конфигурации](#получение-доступа-к-конфигурации)
- [Добавление новых параметров конфигурации](#добавление-новых-параметров-конфигурации)
  - [Добавление простых типов (строки, числа)](#добавление-простых-типов-строки-числа)
  - [Добавление списков и сложных типов](#добавление-списков-и-сложных-типов)
  - [Использование @property декоратора](#использование-property-декоратора)
- [Примеры использования конфигурации](#примеры-использования-конфигурации)
- [Лучшие практики](#лучшие-практики)

## Общее описание конфигурации

В данном проекте мы используем библиотеку `pydantic_settings` для управления конфигурацией. Это позволяет:

- Валидировать параметры конфигурации при загрузке
- Автоматически загружать переменные из окружения и файла `.env`
- Задавать значения по умолчанию
- Иметь строгую типизацию параметров
- Гибко настраивать приоритеты источников конфигурации

## Структура и расположение конфигурации

Конфигурация определяется в файле `bot/settings.py`. Основной класс конфигурации - `Config`, который наследуется от `BaseSettings` из библиотеки `pydantic_settings`.

```python
# bot/settings.py
from pathlib import Path
from pydantic_settings import BaseSettings

# Получаем путь к файлу .env, который находится в директории выше
ENV_PATH = Path(__file__).parent.parent / ".env"

class Config(BaseSettings):
    BOT_TOKEN: str = "8121070643:AAHfGqB0JoE9Pe8MwTCN5jGppY71ZMrFsvQ"
    DATABASE_URL: str = "postgresql://ctf:ctf@localhost:5432/ctf"
    TEACHER_IDS: str = "123456789,987654321"
    SENTRY_DSN: str = "https://1ec97a8cca639cde4c69d8b8597dca04@o4507197457432576.ingest.us.sentry.io/4508985176555520"
    ENV: str = "dev"

    class Config:
        env_file = ENV_PATH
        extra = "allow"  # Разрешить дополнительные параметры

# Создаем экземпляр конфигурации
config = Config()
```

## Работа с переменными окружения и файлом .env

### Что такое переменные окружения и файл .env

Переменные окружения - это переменные, которые доступны процессам, запущенным в операционной системе. Они используются для хранения конфигурационных данных, которые могут различаться в разных средах (разработка, тестирование, продакшн).

Файл `.env` - это текстовый файл, который содержит пары "ключ=значение" и используется для установки переменных окружения локально, без необходимости их реального добавления в системные переменные окружения.

### Структура файла .env

Файл `.env` имеет простую структуру:

```
# Пример файла .env
BOT_TOKEN=your_real_bot_token_here
DATABASE_URL=postgresql://username:password@localhost:5432/dbname
ADMIN_NICKNAMES=realadmin1,realadmin2,realadmin3
ENV=production
```

### Приоритет загрузки конфигурации

При использовании `pydantic_settings` порядок приоритета при загрузке значений следующий (от высшего к низшему):

1. Значения, переданные при создании экземпляра `Config` 
2. Переменные окружения
3. Переменные из файла `.env`
4. Значения по умолчанию, указанные в классе `Config`

Это означает, что если переменная определена как в переменных окружения, так и в файле `.env`, будет использовано значение из переменных окружения.

### Настройка пути к файлу .env

В вашем проекте путь к файлу `.env` настроен следующим образом:

```python
# Получаем путь к файлу .env, который находится в директории выше
ENV_PATH = Path(__file__).parent.parent / ".env"

class Config(BaseSettings):
    # ...
    class Config:
        env_file = ENV_PATH
        # ...
```

Это обеспечивает поиск файла `.env` в корневой директории проекта, на уровень выше по отношению к директории `bot`.

### Проверка загрузки переменных окружения

Чтобы убедиться, что переменные окружения загружаются правильно, можно добавить отладочную информацию:

```python
if __name__ == "__main__":
    print(f"Config as a dict:\n{config.__dict__}")
    print(f"TEACHER_IDS: {config.TEACHER_IDS}")
    print(f"Teacher IDs list: {config.TEACHER_IDS.split(',')}")
```

## Получение доступа к конфигурации

Для использования конфигурации в других модулях проекта импортируйте экземпляр `config`:

```python
from settings import config

# Использование параметров
bot_token = config.BOT_TOKEN
database_url = config.DATABASE_URL
```

## Добавление новых параметров конфигурации

### Добавление простых типов (строки, числа)

Для добавления новых параметров простых типов (строки, числа, булевы значения), достаточно добавить новое поле в класс `Config` с указанием типа и значения по умолчанию:

```python
class Config(BaseSettings):
    # Существующие параметры...
    
    # Новая строковая переменная
    API_KEY: str = "default_api_key"
    
    # Новая числовая переменная
    MAX_CONNECTIONS: int = 10
    
    # Новая булева переменная
    DEBUG_MODE: bool = False
```

### Добавление списков и сложных типов

Для добавления списков или других сложных типов можно использовать аннотации типов Python и обработку данных:

```python
from typing import List, Dict, Optional

class Config(BaseSettings):
    # Существующие параметры...
    
    # Список строк
    ALLOWED_USERS: List[str] = ["user1", "user2", "user3"]
    
    # Словарь с конфигурацией
    SERVICE_CONFIG: Dict[str, str] = {"timeout": "30s", "retries": "3"}
    
    # Опциональное значение
    OPTIONAL_PARAM: Optional[str] = None
```

Также для списков можно использовать строковое представление с разделителями и методы для преобразования:

```python
class Config(BaseSettings):
    # Существующие параметры...
    
    # Строка с разделителями, которую можно преобразовать в список
    ALLOWED_HOSTS_STR: str = "localhost,127.0.0.1"
    
    @property
    def ALLOWED_HOSTS(self) -> List[str]:
        """Преобразует строку ALLOWED_HOSTS_STR в список строк."""
        return self.ALLOWED_HOSTS_STR.split(",")
```

### Использование @property декоратора

Декоратор `@property` позволяет создавать вычисляемые свойства, которые могут выполнять преобразования данных или логику при обращении к ним:

```python
class Config(BaseSettings):
    # Существующие параметры...
    
    # Получение списка ID преподавателей через @property
    @property
    def TEACHER_IDS_LIST(self) -> List[str]:
        """Возвращает список ID преподавателей из строки TEACHER_IDS."""
        return self.TEACHER_IDS.split(",")
    
    # Преобразование строки в число
    PORT_STR: str = "8080"
    
    @property
    def PORT(self) -> int:
        """Преобразует строковое представление порта в число."""
        return int(self.PORT_STR)
    
    # Вычисляемое свойство на основе других параметров
    @property
    def IS_PRODUCTION(self) -> bool:
        """Определяет, является ли окружение продакшном."""
        return self.ENV.lower() == "production"
```

## Примеры использования конфигурации

### Пример 1: Базовое использование

```python
from settings import config

# Использование строкового параметра
bot_token = config.BOT_TOKEN

# Использование списка ID преподавателей
teacher_ids_list = config.TEACHER_IDS.split(",")
for teacher_id in teacher_ids_list:
    print(f"Teacher ID: {teacher_id}")
```

### Пример 2: Использование property

```python
from settings import config

# Предположим, что мы добавили свойство TEACHER_IDS_LIST
teacher_ids = config.TEACHER_IDS_LIST  # Уже список, не нужно делать split()

# Проверка, является ли пользователь преподавателем
def is_teacher(user_id):
    return str(user_id) in config.TEACHER_IDS_LIST
```

### Пример 3: Использование в функциях

```python
from settings import config

def connect_to_database():
    """Подключение к базе данных с использованием DATABASE_URL из конфигурации."""
    db_url = config.DATABASE_URL
    # ... логика подключения к базе данных
    return db_connection
```

## Лучшие практики

1. **Используйте типизацию**: Всегда указывайте тип для параметров конфигурации.
2. **Задавайте значения по умолчанию**: Это поможет избежать ошибок, если значение не указано в `.env`.
3. **Используйте @property для преобразования данных**: Это упрощает использование конфигурации в коде.
4. **Храните чувствительные данные в `.env`**: Никогда не коммитьте реальные токены и пароли в код.
5. **Документируйте параметры**: Добавляйте комментарии для объяснения назначения каждого параметра.
6. **Используйте валидацию**: Pydantic позволяет добавлять валидаторы для параметров.
7. **Добавьте .env в .gitignore**: Чтобы предотвратить случайное добавление секретов в репозиторий.
8. **Предоставляйте шаблон .env.example**: Создайте файл `.env.example` с примерами параметров без реальных значений.

Пример с валидацией:

```python
from pydantic import validator
from pydantic_settings import BaseSettings

class Config(BaseSettings):
    # Существующие параметры...
    
    MIN_PASSWORD_LENGTH: int = 8
    
    @validator("MIN_PASSWORD_LENGTH")
    def validate_min_password_length(cls, v):
        if v < 6:
            raise ValueError("Минимальная длина пароля должна быть не менее 6 символов")
        return v
```

### Пример файла .env.example

Вот пример файла `.env.example`, который можно добавить в репозиторий:

```
# Токен бота Telegram (получить у BotFather)
BOT_TOKEN=your_bot_token_here

# URL для подключения к базе данных PostgreSQL
DATABASE_URL=postgresql://username:password@host:port/database_name

# Список ID преподавателей (разделенный запятыми)
TEACHER_IDS=123456789,987654321

# Настройки для Sentry (мониторинг ошибок)
SENTRY_DSN=your_sentry_dsn_here

# Окружение (dev, staging, production)
ENV=dev
```

Новые разработчики должны скопировать этот файл в `.env` и заполнить нужными значениями.

---

Этот документ описывает основы работы с конфигурацией в проекте. При возникновении вопросов обращайтесь к документации библиотеки [pydantic-settings](https://docs.pydantic.dev/latest/usage/pydantic_settings/) или к более опытным разработчикам проекта.